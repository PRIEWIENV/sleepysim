\documentclass{llncs}
\usepackage{algorithm,algorithmic}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{float}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{llncsdoc}
\usepackage{color}
\usepackage{ifpdf}
\usepackage{amsmath}
\begin{document}
\markboth{\$ Simulator for Distributed Sleepy
Consensus}{\$ Simulator for Distributed Sleepy Consensus}
\thispagestyle{empty}
\begin{flushleft}
\LARGE\bfseries Distributed Consensus\\[2cm]
\end{flushleft}
\rule{\textwidth}{1pt}
\vspace{2pt}
\begin{flushright}
\Huge
\begin{tabular}{@{}l}
Simulator for\\
Sleepy Consensus Protocol\\[6pt]
{\Large SJTU 2017 Cornell Summer Workshop}
\end{tabular}
\end{flushright}
\rule{\textwidth}{1pt}
\vfill
\begin{flushleft}
\large\itshape
\begin{tabular}{@{}l}
{\Large\upshape\bfseries Instructor }\\[8pt]
Elaine\enspace Shi \\[5pt]
Cornell\enspace University\\[5pt]
\end{tabular}
\end{flushleft}
\newpage
%
\section*{Our Group:}
%
\begin{flushleft}
\begin{tabular}{l@{\quad}l@{\hspace{3mm}}l@{\qquad}l}
$\bullet$&\multicolumn{3}{@{}l}{\bfseries Framework Team Members}\\[1mm]
% &\multicolumn{3}{@{}l}{Springer-Verlag}\\
% &\multicolumn{3}{@{}l}{Computer Science Editorial}\\
% &\multicolumn{3}{@{}l}{Tiergartenstra�e 17}\\
% &\multicolumn{3}{@{}l}{69121 Heidelberg}\\
% &\multicolumn{3}{@{}l}{Germany}\\[0.5mm]
 & Junxiang Huang       & & 841450297@qq.com\\
 & Yifei Pu       & &pkq2006@gmail.com\\[2mm]
$\bullet$&\multicolumn{3}{@{}l}{\bfseries Honest Node Team Members}\\[1mm]
 & Tiancheng Xie       & & wjxtcsgx@hotmail.com\\
 & Jiaheng Zhang      & &ZHANGJIAHENG@sjtu.edu.cn\\
 & Xiaotian You    &  & youxiaotian@hotmail.com\\
 & Shuyang Tang         &  & tangshuyang25@163.com\\
 & Chengyao Li   &  & cyli2014@sjtu.edu.cn\\[2mm]
 $\bullet$&\multicolumn{3}{@{}l}{\bfseries Adversary Members}\\[1mm]
 & Qingrong Chen      & & chenqingrong@sjtu.edu.cn\\
 & Ruisheng Cao      & &211314@sjtu.edu.cn\\
 & Shiquan Zhang    &  & zsq007@sjtu.edu.cn\\
 & Haochen Huang  &  & hhc98598@189.cn\\[2mm]
$\bullet$&\multicolumn{3}{@{}l}{\bfseries Integrators}\\[1mm]
 & Feiyang Qiu   &  & st.yeah@gmail.com\\
 & Lingkun Kong  &  & klk316980786@sjtu.edu.cn\\
 & Lanqing Liu    &  & sunnysunny@sjtu.edu.cn\\
 & Jialu Li          &  & 790359064@qq.com\\[2mm]
\\
\\
\\
\\
\\
\\
\\
% \noalign{\rule{\textwidth}{1pt}}
% \noalign{\vskip2mm}
$\bullet$&\multicolumn{3}{@{}l}{\bfseries Where to find our project?}\\[1mm]
 & https://github.com/initc3/sleepysim & & SleepySim\\[2mm]
\end{tabular}
\end{flushleft}


%
\newpage
\tableofcontents
\newpage
%
\section{Introduction}
\quad Consensus protocol serves as the core of distributed computing and also provides a foundational building block for cryptocurrency protocols. In traditional cryptocurrency schemes, proof-of-work (PoW) is leveraged to provide consistency and chain quality for the underlying blockchain. However, proof-of-work is notoriously indifferent for its waste of energy and the potential of the computing power centralization. To face this issue, proof-of-stake (PoS) is proposed to replace proof-of-work. In  Pass and Shi's \emph{sleepy consensus} article (eprint 2016/918) \cite{Sleepy}, a PoS protocol is constructed to realize consensus on the “linearly ordered log” abstraction -- often referred to as state machine replication or linearizability in the distributed systems literature. This scheme is named as sleepy consensus protocol, which respects two important resiliency properties, i.e., consistency and liveness. Moreover, in sleepy consensus model, players can be either online (alert) or offline (asleep), and their online status may change at any point during the protocol execution.

Algorithm \ref{algo1} presents how sleepy consensus protocol works. The protocol takes a parameter $p$ as input, where $p$ denotes the probability each node is elected leader in a single time step. All nodes that just spawned will invoke the init entry point. During initialization, a node generates a signature key pair and registers the public key with the public-key infrastructure $F_{CA}$.
\vspace{-4mm}
\begin{algorithm}
\caption{Sleepy Consensus Protocol}
\label{algo1}
\footnotesize
  \begin{algorithmic}[1]
  \renewcommand{\algorithmicrequire}{\textbf{If On Initialization:}}
  \renewcommand{\algorithmicensure}{\textbf{If On Received \emph{chain'}:}}
  % \renewcommand{\algorithmiclastcon}{\textbf{Every Time Step:}}
  \REQUIRE
  \STATE Let $(pk,sk):=\sum.\mbox{gen}()$
  \STATE Register $pk$ with $F_{CA}$
  \STATE Let \emph{chain} $:=$ \emph{genesis}

  \ENSURE
  \STATE Assert $|$\emph{chain'}$| > |$\emph{chain}$|$ and \emph{chain'} is valid w.r.t. eligible and the current time $t$
  \STATE \emph{chain} $:=$ \emph{chain'} and gossip \emph{chain}

  \renewcommand{\algorithmicensure}{\textbf{Every Time Step:}}
  \ENSURE
  \STATE Receive input $\mbox{transactions}(\mbox{txs})$
  \STATE Let $t$ be the current time
  \IF {$\mbox{eligible}^t(P)$ where $P$ is the current node's party identifier}
  \STATE Let $\sigma := \sum.\mbox{sign}(sk, \mbox{\emph{chain}}[−1].h, \mbox{txs}, t), h':= d(\mbox{\emph{chain}}[−1].h, \mbox{txs}, t, P, \sigma)$
  \STATE Let $B := (\mbox{\emph{chain}}[−1].h, \mbox{txs}, t, P, \sigma, h')$, let $\mbox{\emph{chain}} := \mbox{\emph{chain}}||B$ and gossip \emph{chain}
  \ENDIF
  \STATE Output $\mbox{\emph{extract}}(\mbox{\emph{chain}})$ to $Z$ where $\mbox{\emph{extract}}()$ is the function outputs an ordered list containing the $\mbox{txs}$ extracted from each block in \emph{chain}
  \renewcommand{\algorithmicensure}{\textbf{\emph{Subroutine} $\mbox{eligible}^t(P)$:}}
  \ENSURE
  \IF {$H(P, t) < D_p$ and $P$ is a valid party of this protocol.} \RETURN 1
  \ELSE \RETURN 0
  \ENDIF
  \end{algorithmic}
\end{algorithm}
\vspace{-5mm}

Now, the sleepy protocol proceeds very much like a proof-of-work blockchain, except that instead of solving computational puzzles, in this protocol a node can extend the chain at time $t$ iff it is elected leader at time $t$. To extend the chain with a block, a leader of time $t$ simply signs a tuple containing the previous block’s hash, the node’s own party identifier, the current time $t$, as well as a set of transactions to be confirmed. Leader election can be achieved through a public hash function $H$ that is modeled as a random oracle.
The difficulty parameter $D_{p}$ is defined such that the hash outcome is less than $D_{p}$ with probability $p$. For simplicity, here we describe the scheme with a random oracle $H$ -- however as we explain in this section, $H$ can be removed and replaced with a pseurdorandom function and a common reference string.

In this document, we build a simulator for monitoring the real-world performance of sleepy consensus protocol by constructing a framework which implements Algorithm \ref{algo1}, as well as imitating behaviors of honest players and corrupted/adversarial players in the meanwhile. After analyzing the simulating results, \textbf{we know ... add text here}

This document is organized as follows. In Section 2, we introduce the framework of simulator. In Section 3, we present how honest players work while simulating. And in Section 4, we imitate the adversarial players' behavior and attack the sleepy consensus protocol by several algorithms. We give the analysis of simulating results in Section 5. Finally, we draw conclusions in Section 6.

\section{The Framework of Simulator}
%
\quad In this section, we will illustrate the construction of the framework of our simulator. We will give a detailed introduction of how the framework work. 

%
\subsection{Protocol of the Framework}

\quad There are four underlying parts of our framework. They are controller, network, honest nodes and adversary. The algorithm of our protocol has been 
described in the last section. In this section, I will give a more detailed introdution of our protocol and framework.

\vspace{-4mm}
\begin{figure}
	\centering
	\includegraphics[width=3.0in]{Figures/Initialization.jpg}
	\vspace{-3mm}
	\caption{This figure represents the initialization of the whole system.}
\end{figure}

The network part defines some basic behaviors of the system including sending message and receiving message. When there are some messaging sending demands, the network will receive the messages from the nodes . And after some judgments and operating, the messages will be sent to the destination nodes from the framwork. 
In the network, there are a buffer storaging the messages needed to be sent to each nodes including honest nodes and corrupted nodes and a buffer storaging the messages sent to the adversary. 

Each messages sent by the honest nodes will be intercepted by the adversary. The honest nodes send messages to the network controller, and the network controller storage will send the these messages to the adversary at once.

\vspace{-4mm}
\begin{figure}
	\centering
	\includegraphics[width=2.4in]{Figures/Honest send.jpg}
	\vspace{-3mm}
	\caption{This figure represents how the system works if there is a honest node's message demand.}
\end{figure}

Meanwhile, the adversary make the messages-sending demand  and send them to the network controller. The network controller will package the messages such as include the destination of one message. And the network will send these messages to the honest nodes.

\vspace{-4mm}
\begin{figure}
	\centering
	\includegraphics[width=2.4in]{Figures/Adversary send.jpg}
	\vspace{-3mm}
	\caption{This figure represents how the system works if there is a adversary message demand.}
\end{figure}

The controller part is just like the center of the system. It defines the behavior of the honest nodes, network and adversary. It will determine how to run the hole system in each round and when to stop the running. In each round, the controller will check if the block chain is consistent. If the last $T+1$ blocks are generated by the corrupted nodes, it means that the adversary break the consistency of the chain and the controller will tell the hole system the chain is inconsistency, and then the system will stop to run and output the chain. 

If the block chain is consistent in a round, the controller will run each honest nodes and use the adversary to run the corrupted nodes. The detailed behavior is determined by the honest nodes and the adversary, and will be explained in Section 3 and Section 4. 

\vspace{-4mm}
\begin{figure}
	\centering
	\includegraphics[width=1.8in]{Figures/Running.jpg}
	\vspace{-3mm}
	\caption{This figure represents how the controller runs the system.}
\end{figure}

The controller also determine which node is the leader. To choose the leader, it use a hash function $H$. And it will compare $H$ to $D_{p}$. If $H$ of a node is smaller than the $D_{p}$, this node will build a block.  


\section{The Imitation of Honest Players}
\quad  In this section, we will introduce the imitation of honest players using sleepy consensus protocol.

Sleepy consensus protocol is a consensus protocol that allow honest nodes to be either online or offline. Every node can choose to sleep or not at every round the protocol runs. This protocol will keep the consistency of the whole distributed system as long as the majority of online nodes are honest. Compared with other consensus protocol, the sleepy consensus protocol remain resilience under sporadic participation, which is a more realistic scenario in practice.

Every honest nodes follows the sleepy consensus protocol will choose to sleep or not at every round. If they are online, they will send and receive message from the framework. Since it's a distributed system, they will no be aware of whether the message has been successfully sent to all other honest nodes, but the framework will ensure them that the message will be sent to everyone in $\delta $ rounds, which is the internet transmission delay time.

\subsection{Algorithm for Honest Players}
\quad The specific description of sleepy consensus has been shown in the introduction section. The following is a brief restatement of the protocol.
\begin{itemize}
	\item First, the nodes will elect a leader using the hash function of identity and current time. If
		 $$H(identity, current time) < D$$,
		 where D denotes difficulty, then $Node[identity]$ will be elected to be a leader.\\
	\item Second, the leader can sign the block using the hash value of previous block, transactions and time, then broadcasts.
		 $$Block = sign(sk, block, Trans, time)$$
	\item When one honest node receive a new chain, if the time in block is strictly increasing and the time in the blocks is not in the future, it will update its chain with the new chain.	
\end{itemize}
\subsection{The process to simulate sleepy consensus}
\quad There are several steps to simulate the algorithm of sleepy consensus in our program.
\begin{itemize}
	\item First of all, in every round, the controller will 	let every node to run.\\
	\item Second, the honest node will ask network controller for messages.\\
	\item Third, the network controller will send related message to every node.\\
	\item Then every honest node will ask the controller whether it  has been elected a leader.\\
	\item Next, if one honest node is not elected to be a leader, it will do nothing. However, if it is a leader, it will sign one new block using its secret key with the hash value of previous block, transactions and time stamp. Then it will broadcast it.\\
	\item Finally, whatever one honest node has done, it will give some feedback to controller and network controller.\\
\end{itemize}
\vspace{-4mm}
\begin{figure}
\centering
\includegraphics[width=2.4in]{Figures/honest.pdf}
\vspace{-3mm}
\caption{This figure represents how the honest nodes perform in this simulator using sleepy consensus protocol.}
\end{figure}
%
\section{The Imitation of Adversarial Players}
\quad The previous section introduces the implementation of the honest players' behavior under the sleepy consensus protocol in simulator. This section, in contrast, will present the imitatation of the adversarial players' behavior, which aims to hinder the normal functioning of sleepy consensus protocol under current framework structure. And we design four different attacking algorithms to try to break the consensus between different nodes, i.e., players in the distributed system. What should be noticed is that the adversaries cannot betray the rules established by the framework, while they can only control the network message transportation, i.e., intercepting and delaying the message from honest players. Also, an adversary can manipulate several corrupted nodes in the system, by which adversary impose damage to the system under sleepy consensus protocol.

To simulate the attacks, we assume there is an an adversary lurking within the  framework, who owns competence to intercept all messages coming from honest nodes and decide which to delay in the transportation. Also, the adversary is able to access useful information from these message to fork blocks right behind the private chain he captures. Based on above setting, we design four attacking methods for adversary to smash the consensus holded by system, which are illustrated in following subsections.
\subsection{Na{\"i}ve Adversary Attack}
\quad The \emph{Na{\"i}ve Adversary Attack} corresponds to an attacking method that is quite simple and easy to be came up with when knowing how the sleepy consensus protocol works. Figure \ref{naive} illustrates how na{\"i}ve adversaries to break the consistency of sleepy consensus. In this figure, when honest players add blocks to the main chain which they think is longest (that is the reason why there are several folks in Figure \ref{naive} -- blocks linked by dashed arrows), adversaries mine their own private chain and check whether the length of longest added blocks is larger than security parameter $T$ in every time step. If the longest chain added by honest nodes has length larger than $T$ yet smaller than the length of private chain mined by adversaries, the attacker can, just like the red arrow in Figure \ref{naive}, add their private chain to a specific block in public chain and thus damaging the consistency of sleepy consensus, since some blocks which are confirmed be fixed in main chain are replaced by blocks forged by adversaries.
\vspace{-4mm}
\begin{figure}
\centering
\includegraphics[width=4.3in]{Figures/Naive-Attack.pdf}
\vspace{-3mm}
\caption{This figure represents the attack which na{\"i}ve adversaries impose to the sleepy consensus. The consistency of consensus will break when the length of private chain mined by adversaries is larger than the length of the longest private chain mined by honest nodes, and the later one is supposed be larger than security parameter $T$, which denotes the time round number a block can be confirmed as secure, i.e., be eternally fixed in main block chain.}
\label{naive}
\end{figure}
\subsection{Selfish Adversary Attack}
\quad The selfish adversary attack is integrated with the concept of \emph{selfish mining}, which is proposed by Eyal et al. \cite{Selfish-Attack}. To illustrate, if everyone adheres to the sleepy consensus protocol, then a node with computation power of 10\% should also get 10\% profit from mining for expectation.
However, the aim of selfish mining is to waste honest nodes' computation power and increase its revenue for mining blocks.

The operation of this attack are quite simple. Firstly, adversaries will mine a private chain and hide it from the rest. If the honest node mines a block from the public main chain, then adversaries will publish their private block immediately and delibrately creating a fork in the network. Otherwise, adversary will keep mining on their private chain. To be more specific, if currently the private chain has led the public chain by length of two, then if a new public block is discovered, adversaries would likely to publish all of their two private blocks, thus making their chain the longest chain in the network. If the private chain has led the public chain by length more than two, then for every newly discovered public block, adversaries will publish one of their private blocks to create forks in the network. We can imagine that through making forks in the network, computation is dispersed and also wasted. Thus, the adversary can gain more than he deserves.
\vspace{-7mm}
\begin{figure}[!htbp]
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=1.95in]{Figures/Selfish-Attack-1.pdf}

\text{(a) State 1}
\end{minipage}%
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=1.65in]{Figures/Selfish-Attack-2.pdf}

\text{(b) State 2}
\end{minipage}

\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=1.65in]{Figures/Selfish-Attack-3.pdf}

\text{(c) State 3}
\end{minipage}%
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=1.65in]{Figures/Selfish-Attack-4.pdf}

\text{(d) State 4}
\end{minipage}
\vspace{0mm}
\setlength{\belowcaptionskip}{-10pt}
\caption{This figure shows an example to illustrate how selfish adversary algorithm works. Four subfigures respectively correspond to four different states in one selfish attack.}
\label{selfish}
\vspace{-3mm}
\end{figure}

Figure \ref{selfish} presents an instance of selfish adversary attack.
First of all, in Figure \ref{selfish}(a), the system is initialized with one public block chain, and both honest and adversary players want to add block to the public block chain. In state one, adversaries have already mined three blocks. And according to selfish attack algorithm, they will make a folk chain with same length of longest chain in current state, when one honest player adds his mined block to public chain. Figure \ref{selfish}(b) shows the state 2 when new honest player adds block to the public chain branch he selects. And adversaries need to release another private block he holds to keep the chain he works on has the same length of the longest chain in system. What should be noticed is in state 2, adversaries mined a new private block. In Figure \ref{selfish}(c), i.e., state 3, two honest players come in and add blocks. However, in this state, one player select the branch where adversaries work on as the longest chain while another does not, which causes two longest branches are still with same length. Therefore, in state 3, adversaries just keep mining while add no block to the main chain. In Figure \ref{selfish}(d), i.e., state 4, one honest node comes in and chooses the longest chain he prefers. And adversaries still need to add block to the chain they works on to keep the equivalence of length. However, in this case, adversaries only have one block left. Thus in line with algorithm, they need to release that block and add it to their branch to make sure their chain is now the sole longest chain in system -- just as red line in Figure \ref{selfish}(d) represents. And from then on, both honest nodes and adverseries will select the chain underlined in red color as public chain to keep mining.

\subsection{Stubborn Adversary Attack}
\quad The stubborn adversary attack, which is proposed by Kartik et al. \cite{Stubborn}, is developed from \emph{selfish adversary attack}. The \emph{selfish mining} strategy withholds blocks when it is "in the lead" but cooperates with the honest network when it falls behind. However the new \emph{stubborn mining} strategies is that \emph{the attacker should not give up so easily!} In this case the attacker can increase profits by mining on its private chain more often, even under circumstances where a selfish-mining attacker would acquiesce to the public chain.

We integrate \emph{Equal Fork stubborn} and \emph{Trail stubborn} mining strategies in our simulator. Both attacks are similar to \emph{selfish adversary attack} and modify a certain part of it. For \emph{Equal Fork stubborn}, adversaries will mine a private chain and hide it from the rest. If the honest node mines a block from the public main chain, the F-stubborn miner would conceal her new block and continue mining on it privately instead of hurry to reveal her new block to the public. In this way the adversaries can make the honest waste more than one block than \emph{selfish adversaries}.
\vspace{-7mm}
\begin{figure}[!htbp]
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=1.65in]{Figures/Stubborn-1.pdf}

\text{(a) State 1}
\end{minipage}%
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=1.65in]{Figures/Stubborn-2.pdf}

\text{(b) State 2}
\end{minipage}

\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=1.65in]{Figures/Stubborn-3.pdf}

\text{(c) State 3}
\end{minipage}%
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=1.75in]{Figures/Stubborn-4.pdf}

\text{(d) State 4}
\end{minipage}
\vspace{0mm}
\setlength{\belowcaptionskip}{-10pt}
\caption{This figure gives an example to illustrate how equal fork stubborn adversary algorithm works. Four subfigures respectively correspond to four different states in one equal fork stubborn attack.}
\label{equal}
\vspace{-3mm}
\end{figure}

Figure \ref{equal} presents an instance of \emph{Equal Fork stubborn} attack. The initial state is the same as that in \emph{selfish attack}, in which the adversaries have mined three blocks. When the honest node mines a block from the public chain, adversaries just keep mining private blocks. Eventually adversaries can publish all their private blocks and becomes the longest chain, discarding the blocks mined by honest nodes.

\emph{Trail stubborn} can be considered as a generalization of \emph{selfish mining}. In \emph{selfish attack} adversaries will give up mining once the private chain falls behind the public chain. However for \emph{Trail stubborn} adversaries continue mining on it, in the hope of catching up. The private chain can lag behind the public by \emph{j} blocks before giving up, where in \emph{selfish attack} $j = 1$.
\vspace{-7mm}
\begin{figure}[!htbp]
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=2.3in]{Figures/Trail-1.pdf}

\text{(a) State 1}
\end{minipage}%
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[height=0.8in, width=2.3in]{Figures/Trail-2.pdf}

\text{(b) State 2}
\end{minipage}

\vspace{0mm}
\setlength{\belowcaptionskip}{-10pt}
\caption{This figure gives an example to illustrate how trail stubborn adversary algorithm works. Two subfigures respectively correspond to two different states in one trail stubborn attack.}
\label{trail}
\vspace{-3mm}
\end{figure}

Figure \ref{trail} explains how \emph{Trail stubborn} works. Initially the private chain lags behind the public by  $i (i < j)$ blocks. But adversaries will keep mining and once they exceed the public chain they will finally publish the private chain and damage the consistency.
\subsection{Selfish Eclipse Attack}
\quad We use terminology \emph{eclipse attack} to describe network attacks where the adversary essentially partitions the honest miners into the public and the eclipsed as shown in Figure \ref{eclipsed}. The adversary controls the communication between the public and the eclipsed.

There are two ways for the adversary to attack the eclipsed. The adversary can choose to \emph{destroy the eclipsed victim}, which means that the adversary ignores all of the blocks mined by the eclipsed. This has the effect of destroying the computation power of the eclipsed and therefore increases the adversary's effective gain. The can also \emph{collude with the eclipsed victim} and force her to cooperate. Both the adversary and the eclipsed would maintain a single private blockchain and the adversary would accept all the blocks mined by the eclipsed.

\vspace{-4mm}
\begin{figure}
\centering
\includegraphics[width=2.3in]{Figures/eclipse.pdf}
\vspace{-3mm}
\caption{This figure illustrates that selfish eclipse attack can separate the public and the eclipsed to \emph{destroy the eclipsed victim} or \emph{collude with the eclipsed victim}}. 
\label{eclipsed}
\end{figure}
\section{The Analysis of Simulating Results}
\quad Here is the analysis of Simulating Results. In order to find the influence of different parameters on our system, we try some tests on the different parameters in our protocol such as the number of adversary nodes, maximum network delay and difficulty. There are some results of the tests.

First of all, the adversary's success increases as the number of adversary nodes increases. For example, in our protocol, the total number of nodes is one hundred, and difficulty is $0.1$, maximum network delay is $1$ round, and $T = 10$. If the number of adversary nodes is more than fifty, then it will break consistency with high probability. Otherwise, it can not break consistency within some rounds with high probability.\\
\section{Conclusion}
In conclusion....


\begin{thebibliography}{}  % (do not forget {})

\bibitem{Sleepy}
Bentov, I., Pass, R., \& Shi, E. (2016). The Sleepy Model of Consensus. \emph{IACR Cryptology ePrint Archive}, 2016, 918.
\bibitem{Selfish-Attack}
Eyal, I., \& Sirer, E. G. (2014, March). Majority is not enough: Bitcoin mining is vulnerable. In \emph{International conference on financial cryptography and data security} (pp. 436-454). Springer, Berlin, Heidelberg.
\bibitem{Stubborn}
Nayak, K., Kumar, S., Miller, A., \& Shi, E. (2016, March). Stubborn mining: Generalizing selfish mining and combining with an eclipse attack. In Security and Privacy (EuroS\&P), 2016 IEEE European Symposium on (pp. 305-320). IEEE.
\end{thebibliography}
%
\end{document}

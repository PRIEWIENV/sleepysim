package com.sleepysim;

import javax.crypto.KeyGenerator;
import java.util.ArrayList;
import java.util.Random;
import java.security.*;

public class Controller
{
    private Framework framework;
    private Signature_tool signature;
    private Adversary adversary;
    private Integer node_count, adversary_count;
    private Integer delay;
    private Integer T;
    private ArrayList<Node> nodes;
    private boolean is_corrupted[];
    /**
     * Create a controller and initialization, you should initial the whole network
     * to initial the network, you have to generate secret-public key pairs for all node
     * then initialize signature class
     * tell every node about their secret key, and all public keys
     *
     * initialize adversary and framework by calling their construction function.
     *
     * You should tell framework about the node and delay, you must initialize all nodes first and store them into a ArrayList
     *
     * some code have been implemented, you can modify if you like.
     *
     * @param node_count total number of nodes
     * @param adversary_count total number of adversary
     * @param delay network max delay
     * @param T inconsistency threshold
     */
    Controller(Integer node_count, Integer adversary_count, Integer delay, Integer T)
    {
        this.node_count = node_count;
        this.adversary_count = adversary_count;
        this.delay = delay;
        this.T = T;
        this.is_corrupted = new boolean[node_count];
        for (int i = 0; i < is_corrupted.length; i ++)
            is_corrupted[i] = false;
        this.nodes = new ArrayList<>();
        this.framework = new Framework(delay, nodes);
        decide_corrupted();
        try
        {
            KeyPairGenerator key_generator = KeyPairGenerator.getInstance("RSA");
            ArrayList <PublicKey> public_key_table = new ArrayList<>();
            for (int i = 0; i < node_count; i ++)
            {
                KeyPair new_key = key_generator.generateKeyPair();
                public_key_table.add(new_key.getPublic());
                if (is_corrupted[i])
                    nodes.add(new Corrupted_node(i, adversary, new_key.getPrivate(), public_key_table, framework, node_count));
                else
                    nodes.add(new Honest_node(i, new_key.getPrivate(), public_key_table, framework, node_count));
            }
        }
        catch (NoSuchAlgorithmException e)
        {
        }
        //some code goes here
        //for integrate team
    }

    void decide_corrupted()
    {
        Random random = new Random();
        int cnt = 0;
        while (cnt < adversary_count)
        {
            int x = random.nextInt() % node_count;
            if (!is_corrupted[x])
            {
                is_corrupted[x] = true;
                cnt ++;
            }
        }
    }

    /**
     * Detect inconsistency
     * if the last T+1 blocks are generated by adversary, then return true
     * Otherwise return false
     */
    private boolean has_inconsistency(ArrayList <Block> block_list)
    {
        //some code goes here
        //for integrate team
        return false;
    }

    /**
     * Print necessary info to screen
     * You should include total number of corrupted blocks in longest chain and length of longest chain
     */
    private void print_log()
    {
        //some code goes here
        //for integrate team
    }
    public void run()
    {
        Integer round = 0;
        boolean has_inconsistency = false;
        while (!has_inconsistency)
        {
            for (int i = 0; i < node_count; i ++)
            {
                ArrayList <Block> block_list = nodes.get(i).run(round);
                has_inconsistency |= has_inconsistency(block_list);
            }
            print_log();
            framework.next_round();
            round++;
        }
        print_log();
    }
}

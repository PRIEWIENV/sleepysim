package com.sleepysim;

import javafx.util.Pair;
import org.bouncycastle.asn1.eac.UnsignedInteger;

import java.io.Serializable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.security.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Controller
{
    private Network_control networkcontrol;
    private Signature_tool signature;
    private Adversary adversary;
    private Integer node_count, adversary_count;
    private Integer delay;
    private Integer T;
    private static Logger logger = Logger.getLogger("Controller");
    private ArrayList<Node> nodes;
    private Boolean[] is_corrupted;
    private Integer round;
    private byte[] D; //difficulty
    private double difficulty;
    /**
     * Create a controller and initialization, you should initial the whole network
     * to initial the network, you have to generate secret-public key pairs for all node
     * then initialize signature class
     * tell every node about their secret key, and all public keys
     *
     * initialize adversary and networkcontrol by calling their construction function.
     *
     * You should tell networkcontrol about the node and delay, you must initialize all nodes first and store them into a ArrayList
     *
     * some code have been implemented, you can modify if you like.
     *
     * @param node_count total number of nodes
     * @param adversary_count total number of adversary
     * @param delay network max delay
     * @param T inconsistency threshold
     */
    Controller(Integer node_count, Integer adversary_count, Integer delay, Integer T, double difficulty)
    {

        BigInteger b = BigInteger.valueOf(2).pow(256).subtract(BigInteger.ONE);
        BigDecimal bd = new BigDecimal(b);
        bd = bd.multiply(BigDecimal.valueOf(difficulty));
        b = bd.toBigInteger();
        D = new byte[256 / 8];
        for(int i = 256 / 8 - 1; i >= 0; --i)
        {
            D[i] = (byte)b.mod(BigInteger.valueOf(1 << 8)).intValue();
            b = b.divide(BigInteger.valueOf(1 << 8));
        }
        round = 0;
        this.node_count = node_count;
        this.adversary_count = adversary_count;
        this.delay = delay;
        this.T = T;
        this.nodes = new ArrayList<>();
        is_corrupted = Adversary.decide_corrupted(node_count, adversary_count);

        ArrayList<Pair<Integer, PrivateKey>> secret_key_table = new ArrayList<>();
        try
        {
            KeyPairGenerator key_generator = KeyPairGenerator.getInstance("RSA");
            ArrayList <PublicKey> public_key_table = new ArrayList<>();
            ArrayList <Corrupted_node> corrupted = new ArrayList<>();
            this.networkcontrol = new Network_control(delay, node_count);
            for (int i = 0; i < node_count; i ++)
            {
                KeyPair new_key = key_generator.generateKeyPair();
                public_key_table.add(new_key.getPublic());
                if (is_corrupted[i])
                {
                    Corrupted_node e = new Corrupted_node(i, adversary, new_key.getPrivate(), public_key_table, networkcontrol, node_count);
                    nodes.add(e);
                    secret_key_table.add(new Pair<>(i, new_key.getPrivate()));
                    corrupted.add(e);
                }
                else
                    nodes.add(new Honest_node(i, new_key.getPrivate(), public_key_table, networkcontrol, node_count, this));
            }
            adversary = new Naive_adversary(node_count, is_corrupted, secret_key_table, public_key_table, corrupted, T, this, networkcontrol);
        }
        catch (NoSuchAlgorithmException e)
        {
        }
        //some code goes here
        //for integrate team
    }

    /**
     * Detect inconsistency
     * if the last T+1 blocks are generated by adversary, then return true
     * Otherwise return false
     */
    private boolean has_inconsistency(ArrayList <Block> block_list)
    {
        if(block_list == null)
            return false;
        //some code goes here
        //for integrate team
        if (block_list.size() < T + 1)
            return false;
        for (int i = block_list.size() - 1; i > block_list.size() - T - 1; i --)
            if (!is_corrupted[block_list.get(i).get_creator()])
                return false;
        return true;
    }

    /**
     * Print necessary info to screen
     * You should include total number of corrupted blocks in longest chain and length of longest chain
     */
    private void print_log()
    {
        //some code goes here
        //for integrate team
    }
    public void run()
    {
        boolean has_inconsistency = false;
        while (!has_inconsistency)
        {
            for (int i = 0; i < node_count; i ++)
            {
                ArrayList <Block> block_list = nodes.get(i).run(round);
                has_inconsistency |= has_inconsistency(block_list);
            }
            {
                ArrayList <Block> block_list = adversary.run(round);
               // has_inconsistency |= has_inconsistency(block_list);
            }
            print_log();
            networkcontrol.next_round();
            round++;
        }
        print_log();
    }
    public boolean is_leader(Integer id, Integer round)
    {
        if(round == -1)
            round = this.round;
        try
        {
            byte[] b = Hash.hash(To_byte_array.to_byte_array(new Pair<>(id, round)));
            for(int i = 0; i < b.length; ++i)
            {
                if(b[i] != D[i])
                {
                    Boolean result = (int)(b[i] & 0xff) < (int)(D[i] & 0xff);
                    //if(result)
                    //    logger.log(Level.INFO, "Round " + round.toString() + ", elected leader " + id.toString());
                    return result;
                }
            }
            return false;
        }
        catch (Exception e)
        {
            logger.log(Level.SEVERE, "leader election failed, id = " + id.toString());
            e.printStackTrace();
        }
        return false;
    }
}
